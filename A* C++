#include <iostream>
#include <vector>
#include <queue>
#include <cmath>

using namespace std;
//initialize stuff- good form to lay as global variables?
vector<int> finish;
vector<int> lastPos;
int endPos;
int maze [3][3]= {0, 2, 3,
                  3, 5, 4,
                  2, 6, 1};//-1 start, 2 end
int rows = sizeof maze / sizeof maze[0];
int cols = sizeof maze[0] /sizeof(int);
bool visited [3][3] = {false, false, false, false, false, false, false, false, false};
double E [3][3];
double C [3][3];
priority_queue<int> pos;

void buildQueue();
void expandPath();

int main (){


    for (int i = 0; i < rows; i++){     //print array
        for (int j = 0; j < cols; j++){
            //cout << maze[i][j] << " ";
            if (maze[i][j] == 0)
                finish.push_back(i*10+j);  //start position beginning of finished
            if (maze[i][j] == 1)
                endPos = i*10 + j;      //set endPos
        }
        //cout << endl;
    }
    for (int i = 0; i < rows; i++){ //create Euclidean heuristic array and combined heuristic array
        for (int j = 0; j < cols; j++){
            int x = abs ((endPos - (i*10 + j))%10); //cout << "x = " << x << " ";
            int y = abs ((endPos - (i*10 + j))/10); //cout << "y = " << y << " ";
            E[i][j] = (double)sqrt(pow(x, 2) + pow(y, 2));
           // cout << E[i][j] << " ";
            C[i][j] = E[i][j] + maze[i][j];
            cout << C[i][j] << " ";
        }
        cout << endl;
    }

    lastPos.push_back(finish.at(0)); //add start pos
    cout << lastPos.front() << endl;
    //while (**end condition not met**)
    buildQueue();
    expandPath();
}
void buildQueue () {
        cout << "in buildQueue" << endl;
        int x = lastPos.back()/10;
        int y = lastPos.back()%10;
        cout << "x = " << x << " y = " << y << endl;
        if (x > 0){
            cout << "up " << endl;
            pos.push(C[x-1][y]);
        }
        if (x < rows){
            cout << "down " << endl;
            pos.push(C[x+1][y]);
        }
        if (y > 0){
            cout << "left " << endl;
            pos.push(C[x][y-1]);
        }
        if (y < cols){
            cout << "right " << endl;
            pos.push(C[x][y+1]);
        }
        while (!pos.empty()){
            cout << pos.top() << endl;
            pos.pop();
        }

}
void expandPath(){
    lastPos.push_back(pos.top());
    pos.pop();
    if (lastPos.back() == 1){

    }
    buildQueue();
}
